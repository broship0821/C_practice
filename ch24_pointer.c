//#include <stdio.h>
//
//
//int main() {
//	/*
//	포인터:
//		메모리의 주소값을 가지는 변수
//		주소 이외의 일반적인 데이터는 가질 수 없고 오직 메모리의 주소값만을 가질 수 있음
//
//	포인터 변수 선언(생성):
//		자료형* 포인터변수명
//
//	포인터 변수 앞에 *(역참조 연산자)를 붙이면 포인터가 가지고 있는 주소 공간을 사용하게됨
//	*/
//
//	//int a = 10;
//	//printf("a값: %d - 주소: %p\n", a, &a);
//
//	//int* pa = &a;
//	//printf("a 주소: %p == pa 값: %p\n", &a, pa);
//	//printf("a 값: %d == *pa 값: %d\n", a, *pa);
//
//	//*pa = 111; // 이렇게 하면 a의 값도 바뀜 (역참조)
//	//printf("a 주소: %p == pa 값: %p\n", &a, pa);
//	//printf("a 값: %d == *pa 값: %d\n", a, *pa);
//	//puts("");
//
//	//double b = 2.2;
//	//double* pb = &b;
//	//printf("b 주소: %p - pb 값: %p\n", &b, pb);
//	//printf("b 값: %.1f - *pb 값: %.1f\n", b, *pb);
//	//puts("");
//
//	//char c = 'C';
//	//char* pc = &c;
//	//printf("c 주소: %p - pc 값: %p\n", &c, pc);
//	//printf("c 값: %c - *pc 값: %c\n", c, *pc);
//	//puts("");
//
//	//int d;
//	//int* pd = &d;
//	//printf("숫자 입력: ");
//	//scanf_s("%d", pd); // *pd가 아닌 pd 하면 d가 위치한 주소에 입력한다는 의미
//	//printf("d: %d\n", d);
//
//	//---------------------------------------------------------------------------------
//
//	/*
//	포인터 변수 크기
//		포인터 변수는 타입에 상관없이 4 or 8 byte로 동일
//	*/
//
//	//int ia;
//	//int* pia = &ia;
//	//printf("ia 크기: %d\n", sizeof(ia));
//	//printf("pia 크기: %d\n", sizeof(pia)); //참조 변수도 자기 공간을 먼저 만든 후 참조
//	//puts("");
//
//	//double da;
//	//double* pda = &da;
//	//printf("da 크기: %d\n", sizeof(da));
//	//printf("pda 크기: %d\n", sizeof(pda));
//	//puts("");
//
//	//char ca;
//	//char* pca = &ca;
//	//printf("ca 크기: %d\n", sizeof(ca));
//	//printf("pca 크기: %d\n", sizeof(pca));
//	//puts("");
//	////기본 자료형과 다르게 포인터 변수는 기본 자료형과 상관없이 항상 똑같은 값을 가짐
//	////컴파일러 환경에 따라 8바이트가 될수도 4바이트가 될수도 있음
//
//	//---------------------------------------------------------------------------------
//
//	/*
//	포인터 연산
//		포인터를 연산하면 주소의 자료형 크기를 기준으로 처리함 - 값이 연산되는게 아니라 주소가 한칸씩 옮겨짐
//	*/
//
//	//int oa;
//	//int* poa = &oa;
//	//printf("poa: %p\n", poa);
//	//printf("poa+1: %p\n", poa+1);
//	//printf("poa+2: %p\n", poa + 2);
//	//puts("");
//	////int형은 4byte니까 4씩 증가
//	//double ob;
//	//double* pob = &ob;
//	//printf("pob: %p\n", pob);
//	//printf("pob+1: %p\n", pob + 1);
//	//printf("pob+2: %p\n", pob + 2);
//	//puts("");
//	////double은 8씩 증가
//	//char oc;
//	//char* poc = &oc;
//	//printf("poc: %p\n", poc);
//	//printf("poc+1: %p\n", poc + 1);
//	//printf("poc+2: %p\n", poc + 2);
//	//puts("");
//	////char는 1씩 증가
//	//int od;
//	//int* pod = &od;
//	//printf("pod: %p\n", pod);
//	//printf("pod+1: %p\n", pod + 1);
//	//printf("pod+2: %p\n", pod + 2);
//	//puts("");
//	//*pod = 10;
//	//printf("%d, %d\n", od, *pod);
//	//*(pod+1) = 12; // 주소는 있는데 생성하지 않아서 오류나는듯
//	//printf("%d, %d\n", od, *pod);
//
//
//
//
//	//---------------------------------------------------------------------------------
//
//	/*
//	배열과 포인터
//	*/
//	
//	//int ar[3] = { 1,2,3 };
//	//int* p = ar;
//	//// ar  [0]  [1]  [2]		p
//	////   |  1  | 2  |  3  |		| F0 |
//	////  F0    F4    F8
//	////
//	//// p			(F0) == ar      (F0)
//	//// p + 1		(F4) == ar + 1  (F4)
//	//// *(p+1)       ( 2) == *(ar+1) ( 2)
//	//// p[1]		    ( 2) == ar[1]   ( 2) //이거랑 위에거는 같은뜻임, 포인터 연산을 쉽게 해준게 인덱스 번호임
//
//	//for (int i = 0; i < 3; i++) {
//	//	printf("ar[%d] : %d, %d, %d, %d\n", i, ar[i], *(ar+i), *(p+i), p[i]); //그래서 표현 방법이 4가지 있음
//	//}
//	////차이점:
//	////ar += 1; ar은 주소값을 가지는 상수이기 때문에 연산 불가
//	//p += 1; //이건 포인터 변수이기때문에 가능
//	////ar++; Error
//	//p++;
//	//printf("*p: %d\n", *p);
//
//	//---------------------------------------------------------------------------------
//
//	////포인터는 *없는게 주소고 *있으면 값, 일반 변수는 &없는게 값이고 & 있으면 주소
//	//int a = 10;
//	//int b = 20;
//	//int c = 30;
//
//	//int* ar[3];
//	//ar[0] = &a;
//	//ar[1] = &b;
//	//ar[2] = &c;
//
//	//for (int i = 0; i < 3; i++) {
//	//	printf("*ar[%d] : %d, %d\n", i, *ar[i], *(*(ar + i))); // 값
//	//	printf("*(ar+%d) : %p, %p\n", i, *(ar + i), ar[i]); // 주소
//	//}
//}